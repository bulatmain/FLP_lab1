# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список(или List) в Прологе можно представить как бинарное дерево и дать следующее рекурсивное определение: пустой список является списком, список состоит из элемента (головы) и другого списка (хвоста). Такое представление показывает каким образом чаще всего происходит работа со списками, обрабатывается голова и рекурсивно вызывается та же функция для хвоста, пока он не будет пустым.

От принятых в императивных языках подходов к хранению данных списки Пролога отличаются, в первую очередь, произвольным типом элементов, такое свободное отношение к типам редко в императивных языках. Как было сказано выше списки Пролога очень похожи на бинарные деревья, с тем допущением, что каждый узел имеет лист. В SWI-Prolog, в частности, присутствует большой набор встроенных функций для обработки списков, что наталкивает на мысль о схожести списков и векторов (вектор -- динамический массив): они часто меняют количество содержащися элементов и действия чаще всего производятся с крайними элементами (функции pop и push у вектора).

## Задание 1.1: Предикат обработки списка

`remove_last_three(R, L) rm_last_three(R, L)` - это предикаты, такие что список L - это список R без трех последних элементов. 

Пример:
```pl
?- remove_last_three([1, 2, 3], L).
L = [].
?- remove_last_three([1, 2, 3, 4], L).
L = [1]
?- remove_last_three([1, 2, 3, 4, 5], L).
L = [1, 2]
```

```pl
% First option
remove_last_three(R, L) :- 
    myappend(L, T, R),
    mylen(T, N),
    N = 3.

% Second option
len_is_three(L) :-
    mylen(L, N),
    N = 3.

just_is(A, A). 

rm_last_three(R, []) :-
    len_is_three(R), !.
rm_last_three([H|T], [H]) :-
    len_is_three(T), !.
rm_last_three([H|T], L) :-
    rm_last_three(T, L1),
    just_is(L, [H|L1]).
```

1-я реализация:
    `remove_last_three(R, L)` при помощи предиката `myappend(L, T, R)` перебирает все L и T такие, что вместе они образуют R. Если |T| == 3, то ,т.к. T - это постфикс, L - это R без трех последних элементов. Очевидно, что удовлетворящая этому условию пара (L, T) единственна, т.е. алгоритм детерминирован.

2-я реализация:
    `rm_last_three([H|T], L)` определяется рекурсивно. Если длина данного списка больше трех, то тогда нужный нам список есть [H|L1], где L1 - список T без последних трех элементов.

## Задание 1.2: Предикат обработки числового списка

`average(L, A)` - предикат такой, что A - среднее арифметическое элементов списка L.

Пример:
```pl
?- average([1, 2, 3], A).
A = 2.
?- average([1, 2, 3, 4], A).
A = 2.5.
```

```pl
sum([], 0).
sum([H|T], S) :-
    sum(T, S1),
    S is H + S1.

average(L, A) :-
    sum(L, S),
    mylen(L, N),
    A is S / N.
```

Среднее арифметическое есть сумма, деленное на количество. Притом сумма элементов списка есть сумма первого его головы и хвста.  

## Задание 1.3: 

## Задание 2: Реляционное представление данных

Термин «реляционный» означает, что теория основана на понятии отношениях (relation) между объектами. Для удовлетворения запроса к таким данным необходимо провести анализ отношений между ними. Таким образом задачей программиста является создание программы, позволяющей осуществлять этот анализ. Самым главным преимуществом такого представления данных является приближенность к реальному миру. Отношения являются логическими и абстрактными, а не физически хранимыми структурами.

Моё представление не похоже на хорошую таблицу из баз данных, данные об оценках в таблице со студентами можно было разместить в отдельной таблице. Таблица занимает немного места: в каждой строке со студентом присутствует список с оценками. Но в тоже время, просмотр таблицы не удобен. Поиск по таблицы будет не удобен так как при сопостовлении каких-либо предметов приходится пробегать по всем ученикам и у каждого ученика нужно пробегать по оценкам. Да, наверное компакность этой таблицы будет иметь плюсы по скорости, при определенных запросах к базе данных.

Данные: 3 (three.pl) Вариант 2

* Напечатать средний балл для каждого предмета
* Для каждой группы, найти количество не сдавших студентов
* Найти количество не сдавших студентов для каждого из предметов

### Задание 2.1: Напечатать средний балл для каждого предмета

`average_grade()` - предикат, который в ходе вычисления печатает средний бал по каждому предмету.

Пример:
```pl
?- average_grade().
LP: 4
true ;
MTH: 3.892857142857143
true ;
FP: 3.857142857142857
true ;
INF: 3.75
true ;
ENG: 3.857142857142857
true ;
PSY: 3.75
true.
```

Реализация:
```pl
average_grade() :-
    subject(Subj, _),
    grade_subj_list(Subj, L),
    average(L, S),
    write(Subj),
    write(': '),
    write(S), nl.


grade_subj_list(Subj, L) :-
    findall(G, (student(_, _, R), member(grade(Subj, G), R)), L).
```

Для нахождения средней оценки по предмету формируется список из оценок по предмету, а после вычислятся среднее по списку. Предметы перебираются предикатом `subject(Subj, _)`.


### Задание 2.2: Для каждой группы, найти количество не сдавших студентов

`count_failed_in_groups()` - предикат, который в ходе вычисления печатает количество несдавших какой-либо экзамен студентов по всем группам.

Реализация:
```pl
count_failed_in_groups() :-
    findall(G, (student(G, _, _)), _Groups),
    sort(_Groups, Groups),
    write_failed_in_groups(Groups).


write_failed_in_groups([]).
write_failed_in_groups([H|T]) :-
    count_failed_in_group(H, S),
    write(H),
    write(': '),
    write(S), nl,
    write_failed_in_groups(T).


count_failed_in_group(G, S) :-
    findall(N, (student(G, _, L), count_failed(L, N)), _N),
    sum(_N, S).


count_failed([], 0).
count_failed([H|T], N) :-
    count_failed(T, N1),
    check_failed(H, C),
    N is C + N1.

check_failed(grade(_, 2), 1) :- !.
check_failed(_, 0).
```

Сначала формируется список групп, он просеиваться так, чтобы содержать только уникальные элементы (при помощи предиката sort(L, R)), затем для каждой группы печатается число ее несдавших студентов (при помощи предиката write_failed_in_groups(Group)). 

Предикат `write_failed_in_groups([H|T])` печатает количество несдавших студентов из группы H, и рекурсивно вызывает себя от T.

`count_failed_in_group(G, S)` считает поличество несдавших в конкретной группе.
`count_failed(L, N)` считает количество несдавших в списках, данных в реляцонной бд.
`check_failed(grade, C)` определяет, сдан ли очередной экзамен. 

### Задание 2.3: Найти количество не сдавших студентов для каждого из предметов

`count_failed_by_subjects()` - этот предикат печатает для каждого предмета количество несдавших его студентов.

Пример:
```pl
?- count_failed_by_subjects().
LP: 0
true ;
MTH: 3
true ;
FP: 3
true ;
INF: 3
true ;
ENG: 2
true ;
PSY: 3
true.
```

Реализация:
```pl
count_failed_in_mark_list([], 0).
count_failed_in_mark_list([H|T], S) :-
    count_failed_in_mark_list(T, S1),
    check_failed_mark(H, C),
    S is C + S1.


check_failed_mark(2, 1) :- !.
check_failed_mark(_, 0).


count_failed_by_subjects() :-
    subject(Subj, _),
    grade_subj_list(Subj, L),
    count_failed_in_mark_list(L, S),
    write(Subj),
    write(': '),
    write(S), nl.
```

Предикат для каждого предмета формирует список оценок по нему среди всех студентов, а затем считает количество двоек в этом списке - это и будет число несдавших экзамен по данному предмету.

## Выводы

Пролог предоставляет пользователю принципиально особенную парадигму программирования и решения задач в целом. Пролог предоставляет механизм определения искомых значений через построение дерева резолюций от данных нами посылок, и это позволяет нам опираться от свойств искомого объекта. Оказывается, при помощи пролога для многих задач можно найти лаконичное и элегантное решение, которое как будто бы определяется само собой. 

Во время составления программ я немало времени уделил использованию трассировки, это помогло мне лучше понять логику Пролога, как он думает, и вникнуть в механизм бэктрекинга. Пролог, для меня, оказался неожиданно мощным средством решения задач, я продолжу более глубокое изучение его механизмов.